# 背包问题

## 01背包问题

> 假定背包的最大容量为W，N件物品，每件物品都有自己的价值和重量，将物品放入背包中使得背包内物品的总价值最大。

示例：
```
Knapsack Max weight : W = 10 (units) 
Total items         : N = 4
Values of items     : val[] = {10, 40, 30, 50} 
Weight of items     : wt[] = {5, 4, 6, 3}
```

### 解决方法

最佳的解决方法当然是动态规划，先得到该问题的局部解然后扩展到全局问题解，避免了暴力破解效率低下的问题。

很重要的一步，构建物品X在不同重量时的价值数组V(Value数组)：
```
V[N][W] = 4 rows * 10 columns
```
一个二维数组，行数是物品的总数量，列数是背包所能承载的最大重量。

数组每一行，都代表一个物品，每一个元素，都代表一个价值，我们重点考虑**每一行不同重量时的价值**，对于每一行，有四个部分要考虑：
* 当前物品价值
* 当前物品重量
* 剩余重量
* 上面一行，同列的价值

用子问题定义状态，这里最重要的计算过程为：
* 不加入该物品时该重量的最大价值`V[item-1][weight]`
* 计算当前物品的价值 + 可以容纳的剩余重量的价值`val[item-1] + V[item-1][weight-wt[item-1]]`

得出状态转移方程：
```
V[item][weight]= max{V[item-1][weight], val[item-1] + V[item-1][weight-wt[item-1]]}
```

包内最大总价值为`V[N][W]`

#### 复杂度

在N次循环中有W次循环 => O(NW)

时间和空间复杂度均为O(NW)

#### Java实现
```Java
class knapsack {
    public static void main(String[] args) throws Exception {
        int val[] = {10, 40, 30, 50};
        int wt[] = {5, 4, 6, 3};
        int w = 10;

        System.out.println(knapsack(val, wt, w));
    }

    public static int knapsack(int val[], int wt[], int w) {
        // 物品的总数
        int N = wt.length;

        // 创建矩阵，行和列均+1
        int[][] V = new int[N + 1][W + 1];

        // 考虑背包容量为0的情况，设置第0行所有列均为0
        for (int col = 0; col <= w; col++) {
            V[0][col] = 0;
        }

        // 考虑没有任何物品的情况，设置第一列所有元素为0
        for (int row = 0; row <= N; row++) {
            V[row][0] = 0;
        }

        // 一行一行填充元素
        for (int item = 1; item <= N; item++) {
            for (int weight = 1; weight <= W; weight++) {
                // 判断当前物品的重量是否小于等于当前列所代表的重量
                if (wt[item-1] <= weight) {
                    // 状态转移方程，两者择大
                    V[item][weight]=Math.max(val[item-1]+V[item-1][weight-wt[item-1]], V[item-1][weight]);
                } else {
                    // 当前物品重量大于当前列重量时，直接继承上一行当前列的价值
                    V[item][weight] = V[item-1][weight];
                }
            }
        }

        // 打印矩阵
        for (int[] rows : V) {
            for (int col : rows) {
                System.out.format("%5d", col);
            }
            System.out.println();
        }

        return V[N][W];
    }
}
```

#### 优化空间复杂度

时间复杂度应该已经不能再优化了,但空间复杂度却可以优化到O(V)。

简单来说，就是将二维数组简化为一维数组。此时需要对weight逆序循环。

具体可参考背包九讲。

#### 初始化细节

如果要求“恰好装满背包”时的最优解，那么我们初始化时将`V[0][0]`初始化为0,其他第一行的元素全部初始化为−∞

---
参考自：
[ImportNew](http://www.importnew.com/13072.html)，上面有图，思路更清晰一些
《背包问题九讲》

